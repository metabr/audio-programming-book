// generated by Fast Light User Interface Designer (fluid) version 1.0104

#include "helloRingGUI.h"

inline void RingModGUI::cb_Choose_i(Fl_Menu_*, void*) {
  isInput = true;
            chooseDevice();
}
void RingModGUI::cb_Choose(Fl_Menu_* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_Choose_i(o,v);
}

inline void RingModGUI::cb_Choose1_i(Fl_Menu_*, void*) {
  isInput = false;
            chooseDevice();
}
void RingModGUI::cb_Choose1(Fl_Menu_* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_Choose1_i(o,v);
}

inline void RingModGUI::cb_Start_i(Fl_Menu_*, void*) {
  play();
}
void RingModGUI::cb_Start(Fl_Menu_* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_Start_i(o,v);
}

inline void RingModGUI::cb_Sto_i(Fl_Menu_*, void*) {
  stop();
}
void RingModGUI::cb_Sto(Fl_Menu_* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_Sto_i(o,v);
}

inline void RingModGUI::cb_E_i(Fl_Menu_*, void*) {
  mainWindow->hide();
}
void RingModGUI::cb_E(Fl_Menu_* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_E_i(o,v);
}

Fl_Menu_Item RingModGUI::menu_[] = {
 {"Setup", 0,  0, 0, 64, 0, 0, 14, 56},
 {"Choose audio &input device", 0,  (Fl_Callback*)RingModGUI::cb_Choose, 0, 0, 0, 0, 14, 56},
 {"Choose audio &output device", 0,  (Fl_Callback*)RingModGUI::cb_Choose1, 0, 0, 0, 0, 14, 56},
 {"&Start playing", 0,  (Fl_Callback*)RingModGUI::cb_Start, 0, 0, 0, 0, 14, 56},
 {"Sto&p playing", 0,  (Fl_Callback*)RingModGUI::cb_Sto, 0, 0, 0, 0, 14, 56},
 {"E&xit", 0,  (Fl_Callback*)RingModGUI::cb_E, 0, 0, 0, 0, 14, 56},
 {0},
 {0}
};

inline void RingModGUI::cb_knobFrq1_i(Fl_Dial* o, void*) {
  double val;
  val = exp(o->value() * (log(frqMax) - log(frqMin))+ log(frqMin));
  dispFrq1->value(val);
  freq1 = val;
  isFreqUpdated = true;
}
void RingModGUI::cb_knobFrq1(Fl_Dial* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_knobFrq1_i(o,v);
}

inline void RingModGUI::cb_knobFrq2_i(Fl_Dial* o, void*) {
  double val;
  val = exp(o->value() * (log(frqMax) - log(frqMin))+ log(frqMin));
  dispFrq2->value(val);
  freq2 = val;
  isFreqUpdated = true;
}
void RingModGUI::cb_knobFrq2(Fl_Dial* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_knobFrq2_i(o,v);
}

inline void RingModGUI::cb_sldrWetVol_i(Fl_Value_Slider* o, void*) {
  wetVolume = o->value();
  isVolUpdated = true;
}
void RingModGUI::cb_sldrWetVol(Fl_Value_Slider* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_sldrWetVol_i(o,v);
}

inline void RingModGUI::cb_sldrDryVol_i(Fl_Value_Slider* o, void*) {
  dryVolume = o->value();
  isVolUpdated = true;
}
void RingModGUI::cb_sldrDryVol(Fl_Value_Slider* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_sldrDryVol_i(o,v);
}

inline void RingModGUI::cb_brwDevSelect_i(Fl_Browser* o, void*) {
  int i = o->value();
  if (isInput) { 
	inDevNum = (int) o->data(i);
	txtInDev->value(o->text(i));
  }
  else {
	outDevNum = (int) o->data(i);
	txtOutDev->value(o->text(i));
  };
}
void RingModGUI::cb_brwDevSelect(Fl_Browser* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_brwDevSelect_i(o,v);
}

inline void RingModGUI::cb_OK_i(Fl_Return_Button*, void*) {
  if (isInput) openInput();
else openOutput();
delete chooseDev;
}
void RingModGUI::cb_OK(Fl_Return_Button* o, void* v) {
  ((RingModGUI*)(o->parent()->user_data()))->cb_OK_i(o,v);
}

RingModGUI::RingModGUI() : frqMin(10), frqMax(2000) {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = mainWindow = new Fl_Double_Window(397, 248, "Ring modulation of a stereo input signal");
    w = o;
    o->user_data((void*)(this));
    { Fl_Menu_Bar* o = new Fl_Menu_Bar(0, 0, 60, 25);
      o->box(FL_THIN_UP_BOX);
      o->menu(menu_);
    }
    { Fl_Dial* o = knobFrq1 = new Fl_Dial(25, 75, 60, 60, "frequency of the 1st modulator sine");
      o->box(FL_ROUND_UP_BOX);
      o->color(51);
      o->selection_color(216);
      o->labelsize(12);
      o->callback((Fl_Callback*)cb_knobFrq1);
      o->align(130);
    }
    { Fl_Dial* o = knobFrq2 = new Fl_Dial(110, 75, 60, 60, "frequency of the 2nd modulator sine");
      o->box(FL_ROUND_UP_BOX);
      o->color(51);
      o->selection_color(9);
      o->labelsize(12);
      o->callback((Fl_Callback*)cb_knobFrq2);
      o->align(130);
    }
    { Fl_Value_Output* o = dispFrq1 = new Fl_Value_Output(30, 45, 50, 25);
      o->box(FL_FLAT_BOX);
      o->color(51);
      o->textsize(12);
    }
    { Fl_Value_Output* o = dispFrq2 = new Fl_Value_Output(115, 45, 50, 25);
      o->box(FL_FLAT_BOX);
      o->color(51);
      o->textsize(12);
    }
    { Fl_Value_Slider* o = sldrWetVol = new Fl_Value_Slider(205, 20, 75, 150, "wet  volume");
      o->type(4);
      o->box(FL_FLAT_BOX);
      o->color(51);
      o->selection_color(216);
      o->labelsize(12);
      o->minimum(1);
      o->maximum(0);
      o->step(0.002);
      o->value(0.5);
      o->textsize(12);
      o->callback((Fl_Callback*)cb_sldrWetVol);
      o->align(130);
    }
    { Fl_Value_Slider* o = sldrDryVol = new Fl_Value_Slider(290, 20, 75, 150, "dry volume");
      o->type(4);
      o->box(FL_FLAT_BOX);
      o->color(51);
      o->selection_color(9);
      o->labelsize(12);
      o->minimum(1);
      o->maximum(0);
      o->step(0.002);
      o->textsize(12);
      o->callback((Fl_Callback*)cb_sldrDryVol);
      o->align(130);
    }
    { Fl_Output* o = txtInDev = new Fl_Output(85, 200, 300, 15, "Input device:");
      o->box(FL_THIN_DOWN_BOX);
      o->color(49);
      o->selection_color(29);
      o->labelsize(12);
      o->textsize(10);
    }
    { Fl_Output* o = txtOutDev = new Fl_Output(85, 220, 300, 15, "Output device:");
      o->box(FL_THIN_DOWN_BOX);
      o->color(49);
      o->labelsize(12);
      o->textsize(10);
    }
    o->end();
    o->resizable(o);
  }
  initFlags();
  isFreqUpdated = true;
  isVolUpdated = true;
  inDevNum = -1;
  outDevNum = -1;
  txtInDev->value("No device. Choose an input device, please");
  txtOutDev->value("No device. Choose an output device, please");
  freq1 = knobFrq1->value();
  freq2 = knobFrq2->value();
  wetVolume = sldrWetVol->value();
  dryVolume = sldrDryVol->value();
  dispFrq1->value(knobFrq1->value());
  dispFrq2->value(knobFrq2->value());
}

void RingModGUI::show() {
  mainWindow->show();
}

Fl_Double_Window* RingModGUI::chooseDevice() {
  Fl_Double_Window* w;
  { Fl_Double_Window* o = chooseDev = new Fl_Double_Window(476, 427, "Choose audio devices");
    w = o;
    o->labelcolor(0);
    o->user_data((void*)(this));
    { Fl_Browser* o = brwDevSelect = new Fl_Browser(5, 5, 465, 365, "Select an audio input device and press \"OK\"");
      o->type(2);
      o->color(51);
      o->labelcolor(80);
      o->textsize(10);
      o->callback((Fl_Callback*)cb_brwDevSelect);
      if (isInput){ chooseDev->label("Choose Audio Input"); o->label("Select an audio input device and press 'OK'"); }
      else {chooseDev->label("Choose Audio Output"); o->label("Select an audio output device and press 'OK'"); }
    }
    { Fl_Return_Button* o = new Fl_Return_Button(195, 390, 90, 30, "OK");
      o->callback((Fl_Callback*)cb_OK);
    }
    o->set_modal();
    o->end();
  }
  if (isInput) getAvailableInputs();
  else getAvailableOutputs();
  chooseDev->show();
  return w;
}
